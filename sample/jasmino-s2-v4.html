<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jasmino — S2 Division Showcase v4</title>
<link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,500;0,9..144,600;0,9..144,700;1,9..144,300;1,9..144,400;1,9..144,500&family=Sora:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
:root {
  --navy:#0B1D34;--dark:#0D2847;--blue:#1B4B8F;--green:#04E586;
  --green-glow:rgba(4,229,134,0.15);--green-dim:rgba(4,229,134,0.06);
  --g50:#FAFBFC;--g100:#F0F2F5;--g150:#E4E7EC;--g200:#D5D9E0;
  --g300:#B0B7C3;--g400:#8892A2;--g500:#6B7280;--g600:#4B5563;--g900:#0C1220;
  --r:12px;--r-lg:18px;--r-2xl:32px;
  --serif:'Fraunces',serif;--sans:'Sora',sans-serif;--mono:'JetBrains Mono',monospace;
  --ease:cubic-bezier(0.16,1,0.3,1);--ease-out:cubic-bezier(0.0,0,0.2,1);
}
*{margin:0;padding:0;box-sizing:border-box}
html{scroll-behavior:smooth}
body{font-family:var(--sans);background:var(--g50);color:var(--g900);-webkit-font-smoothing:antialiased;line-height:1.6}

/* ── Engineering grid background ── */
.eng-grid{
  background-image:
    linear-gradient(rgba(27,75,143,0.035) 1px,transparent 1px),
    linear-gradient(90deg,rgba(27,75,143,0.035) 1px,transparent 1px),
    linear-gradient(rgba(27,75,143,0.06) 1px,transparent 1px),
    linear-gradient(90deg,rgba(27,75,143,0.06) 1px,transparent 1px);
  background-size:20px 20px,20px 20px,100px 100px,100px 100px;
}

/* ── Section container ── */
.s2{max-width:1320px;margin:0 auto;padding:100px 48px 120px}

/* ── Section header ── */
.s2-header{text-align:center;margin-bottom:80px}
.s2-overline{
  font-family:var(--mono);font-size:11px;font-weight:500;letter-spacing:0.18em;
  text-transform:uppercase;color:var(--green);margin-bottom:18px;
  display:flex;align-items:center;justify-content:center;gap:14px;
  opacity:0;transform:translateY(12px);transition:all 0.8s var(--ease) 0.1s;
}
.s2-header.visible .s2-overline{opacity:1;transform:translateY(0)}
.s2-overline::before,.s2-overline::after{content:'';width:28px;height:1px;background:var(--green);opacity:0.35}
.s2-title{
  font-family:var(--serif);font-weight:400;font-size:52px;line-height:1.08;
  letter-spacing:-0.025em;color:var(--g900);margin-bottom:18px;
  opacity:0;transform:translateY(20px);transition:all 0.9s var(--ease) 0.2s;
}
.s2-header.visible .s2-title{opacity:1;transform:translateY(0)}
.s2-title em{font-style:italic;font-weight:300;color:var(--blue)}
.s2-subtitle{
  font-size:16px;line-height:1.75;color:var(--g500);max-width:520px;margin:0 auto;
  opacity:0;transform:translateY(14px);transition:all 0.9s var(--ease) 0.35s;
}
.s2-header.visible .s2-subtitle{opacity:1;transform:translateY(0)}

/* ── Card grid ── */
.div-cards{display:flex;flex-direction:column;gap:32px}
.div-card{
  display:grid;grid-template-columns:1fr 1fr;background:#fff;border-radius:var(--r-2xl);
  overflow:hidden;border:1px solid var(--g150);
  transition:border-color 0.5s var(--ease),box-shadow 0.6s var(--ease),transform 0.5s var(--ease);
  position:relative;opacity:0;transform:translateY(50px);
}
.div-card.visible{opacity:1;transform:translateY(0);transition:opacity 0.7s var(--ease),transform 0.7s var(--ease),border-color 0.5s var(--ease),box-shadow 0.6s var(--ease)}
.div-card:hover{
  border-color:var(--g200);
  box-shadow:
    0 1px 2px rgba(0,0,0,0.02),
    0 4px 8px rgba(0,0,0,0.02),
    0 8px 16px rgba(0,0,0,0.03),
    0 16px 32px rgba(0,0,0,0.04),
    0 32px 64px rgba(0,0,0,0.05);
  transform:translateY(-2px);
}
.div-card:nth-child(even){direction:rtl}
.div-card:nth-child(even)>*{direction:ltr}
.div-card:nth-child(1){transition-delay:0ms}
.div-card:nth-child(2){transition-delay:100ms}
.div-card:nth-child(3){transition-delay:200ms}
.div-card:nth-child(4){transition-delay:300ms}

/* ── Blueprint visual panel ── */
.div-visual{position:relative;min-height:540px;overflow:hidden;display:flex;flex-direction:column}
.div-visual.eng{background:linear-gradient(170deg,#0d1e35 0%,#0a1628 50%,#0c1a2e 100%)}
.div-visual.mfg{background:linear-gradient(170deg,#0b1828 0%,#081220 50%,#0a1524 100%)}
.div-visual.cor{background:linear-gradient(170deg,#0c1b30 0%,#091525 50%,#0b1829 100%)}
.div-visual.rub{background:linear-gradient(170deg,#091420 0%,#060e18 50%,#08111e 100%)}

/* Blueprint grid */
.div-visual::before{
  content:'';position:absolute;inset:0;pointer-events:none;z-index:1;
  background-image:
    linear-gradient(rgba(59,123,219,0.035) 1px,transparent 1px),
    linear-gradient(90deg,rgba(59,123,219,0.035) 1px,transparent 1px),
    linear-gradient(rgba(59,123,219,0.07) 1px,transparent 1px),
    linear-gradient(90deg,rgba(59,123,219,0.07) 1px,transparent 1px);
  background-size:20px 20px,20px 20px,100px 100px,100px 100px;
}
/* Noise texture overlay for paper feel */
.bp-noise{
  position:absolute;inset:0;z-index:3;pointer-events:none;opacity:0.3;
  mix-blend-mode:overlay;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  background-size:128px 128px;
}
/* Blueprint border frame */
.bp-frame{
  position:absolute;inset:14px;pointer-events:none;z-index:4;
  border:1px solid rgba(59,123,219,0.1);border-radius:1px;
  transition:border-color 0.6s var(--ease);
}
.div-card:hover .bp-frame{border-color:rgba(4,229,134,0.1)}
/* Scan line */
.bp-scanline{
  position:absolute;left:14px;right:14px;height:1px;z-index:6;pointer-events:none;
  background:linear-gradient(90deg,transparent 0%,rgba(4,229,134,0.15) 20%,rgba(4,229,134,0.3) 50%,rgba(4,229,134,0.15) 80%,transparent 100%);
  opacity:0;animation:scanDown 6s ease-in-out infinite;
}
@keyframes scanDown{
  0%{top:14px;opacity:0}
  5%{opacity:1}
  90%{opacity:1}
  95%{opacity:0}
  100%{top:calc(100% - 14px);opacity:0}
}
.div-card:nth-child(1) .bp-scanline{animation-delay:0s}
.div-card:nth-child(2) .bp-scanline{animation-delay:1.5s}
.div-card:nth-child(3) .bp-scanline{animation-delay:3s}
.div-card:nth-child(4) .bp-scanline{animation-delay:4.5s}
.three-wrap{flex:1;position:relative;z-index:2}
.three-wrap canvas{display:block;width:100%!important;height:100%!important}

/* Large bg number */
.div-visual-num{
  position:absolute;top:20px;right:24px;z-index:5;pointer-events:none;
  font-family:var(--mono);font-size:96px;font-weight:700;line-height:1;
  color:rgba(59,123,219,0.04);
  transition:color 0.8s var(--ease);
}
.div-card:hover .div-visual-num{color:rgba(4,229,134,0.05)}

/* Corner marks */
.bp-corner{position:absolute;z-index:5;pointer-events:none;transition:opacity 0.5s}
.bp-corner svg{display:block}
.bp-corner.tl{top:14px;left:14px}
.bp-corner.tr{top:14px;right:14px}
.bp-corner.bl{bottom:14px;left:14px}
.bp-corner.br{bottom:14px;right:14px}

/* Crosshair center mark */
.bp-crosshair{
  position:absolute;top:50%;left:50%;z-index:5;pointer-events:none;
  width:24px;height:24px;transform:translate(-50%,-50%);opacity:0.12;
  transition:opacity 0.5s;
}
.div-card:hover .bp-crosshair{opacity:0.2}

/* Blueprint label at bottom */
.bp-label{
  position:absolute;bottom:22px;left:22px;z-index:7;pointer-events:none;
  font-family:var(--mono);font-size:9px;letter-spacing:0.07em;
  text-transform:uppercase;color:rgba(59,123,219,0.3);
  display:flex;align-items:center;gap:7px;
  transition:color 0.5s;
}
.div-card:hover .bp-label{color:rgba(4,229,134,0.3)}
.bp-label .bp-dot{
  width:5px;height:5px;border-radius:50%;
  background:rgba(4,229,134,0.5);
  box-shadow:0 0 6px rgba(4,229,134,0.3);
  animation:bpPulse 2.5s ease-in-out infinite;
}
@keyframes bpPulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.4;transform:scale(0.7)}}

/* Status indicator top-left */
.bp-status{
  position:absolute;top:22px;left:22px;z-index:7;pointer-events:none;
  font-family:var(--mono);font-size:8px;letter-spacing:0.1em;
  text-transform:uppercase;color:rgba(59,123,219,0.2);
  display:flex;align-items:center;gap:5px;
}
.bp-status-dot{
  width:4px;height:4px;border-radius:50%;
  background:rgba(4,229,134,0.6);
  animation:bpPulse 3s ease-in-out infinite 0.5s;
}

/* ── Content panel ── */
.div-content{
  padding:52px 48px;display:flex;flex-direction:column;justify-content:center;
  background:linear-gradient(180deg,#fff 0%,#fafbfd 100%);
  position:relative;
}
/* Subtle left edge accent */
.div-content::before{
  content:'';position:absolute;top:20%;bottom:20%;width:2px;
  background:linear-gradient(to bottom,transparent,var(--green-glow),var(--green),var(--green-glow),transparent);
  opacity:0;transition:opacity 0.6s var(--ease);
}
.div-card:nth-child(odd) .div-content::before{left:0}
.div-card:nth-child(even) .div-content::before{right:0}
.div-card:hover .div-content::before{opacity:1}

/* Staggered content entrance */
.div-content > *{opacity:0;transform:translateY(16px);transition:all 0.6s var(--ease)}
.div-card.visible .div-content > *{opacity:1;transform:translateY(0)}
.div-card.visible .div-content > :nth-child(1){transition-delay:0.15s}
.div-card.visible .div-content > :nth-child(2){transition-delay:0.25s}
.div-card.visible .div-content > :nth-child(3){transition-delay:0.35s}
.div-card.visible .div-content > :nth-child(4){transition-delay:0.45s}
.div-card.visible .div-content > :nth-child(5){transition-delay:0.55s}
.div-card.visible .div-content > :nth-child(6){transition-delay:0.65s}

.div-content-num{
  font-family:var(--mono);font-size:10px;font-weight:500;letter-spacing:0.14em;
  text-transform:uppercase;color:var(--green);margin-bottom:14px;
  display:flex;align-items:center;gap:10px;
}
.div-content-num::after{content:'';flex:1;height:1px;background:linear-gradient(90deg,var(--g150),transparent);max-width:60px}
.div-content-title{
  font-family:var(--serif);font-weight:400;font-size:34px;line-height:1.1;
  letter-spacing:-0.02em;color:var(--g900);margin-bottom:16px;
}
.div-content-desc{font-size:14.5px;line-height:1.8;color:var(--g500);margin-bottom:28px;max-width:420px}

/* Stat box */
.div-stat-inline{
  display:flex;align-items:baseline;gap:10px;margin-bottom:28px;padding:14px 18px;
  background:var(--g50);border-radius:var(--r);border:1px solid var(--g100);
  width:fit-content;position:relative;overflow:hidden;
  transition:border-color 0.3s;
}
.div-stat-inline:hover{border-color:var(--g200)}
.div-stat-inline::before{
  content:'';position:absolute;left:0;top:0;bottom:0;width:3px;
  background:linear-gradient(to bottom,var(--blue),var(--green));border-radius:3px 0 0 3px;
}
.div-stat-inline .num{font-family:var(--mono);font-weight:600;font-size:22px;color:var(--blue);line-height:1}
.div-stat-inline .label{font-family:var(--mono);font-size:11px;color:var(--g400);letter-spacing:0.02em}

/* Service pills */
.div-pills{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:32px}
.div-pill{
  font-family:var(--mono);font-size:10.5px;padding:7px 16px;border-radius:20px;
  background:#fff;color:var(--g600);border:1px solid var(--g200);
  text-decoration:none;transition:all 0.3s var(--ease);cursor:pointer;
  position:relative;overflow:hidden;letter-spacing:0.01em;
}
.div-pill::before{
  content:'';position:absolute;inset:0;background:var(--blue);
  transform:scaleX(0);transform-origin:left;transition:transform 0.35s var(--ease);border-radius:inherit;
}
.div-pill:hover{color:#fff;border-color:var(--blue);transform:translateY(-1px)}
.div-pill:hover::before{transform:scaleX(1)}
.div-pill span{position:relative;z-index:1}

/* Explore link */
.div-explore{
  display:inline-flex;align-items:center;gap:8px;font-size:13px;font-weight:600;
  color:var(--blue);text-decoration:none;
  transition:gap 0.35s var(--ease),color 0.3s;position:relative;padding-bottom:2px;
}
.div-explore::after{
  content:'';position:absolute;bottom:0;left:0;width:0;height:1.5px;
  background:linear-gradient(90deg,var(--blue),var(--green));
  transition:width 0.4s var(--ease);
}
.div-explore:hover{gap:14px}
.div-explore:hover::after{width:100%}
.div-explore svg{width:16px;height:16px;transition:transform 0.3s var(--ease)}
.div-explore:hover svg{transform:translateX(3px)}
/* Subtle breathing animation on arrow */
.div-card.visible .div-explore svg{animation:breathe 2.5s ease-in-out infinite 1.5s}
@keyframes breathe{0%,100%{transform:translateX(0)}50%{transform:translateX(3px)}}
.div-explore:hover svg{animation:none;transform:translateX(3px)}

/* ── Responsive ── */
@media(max-width:1024px){
  .s2{padding:80px 32px 100px}.s2-title{font-size:42px}
  .div-content{padding:40px 36px}.div-content-title{font-size:28px}
}
@media(max-width:768px){
  .s2{padding:60px 20px 80px}.s2-title{font-size:34px}
  .div-card,.div-card:nth-child(even){grid-template-columns:1fr;direction:ltr}
  .div-card:nth-child(even)>*{direction:ltr}
  .div-visual{min-height:320px}.div-content{padding:32px 24px}
  .div-visual-num{font-size:60px}.div-content-title{font-size:26px}
}
</style>
</head>
<body>
<section class="eng-grid">
<div class="s2">
  <div class="s2-header" id="s2hdr">
    <div class="s2-overline">Our Capabilities</div>
    <h2 class="s2-title">Four divisions, one<br><em>integrated</em> model</h2>
    <p class="s2-subtitle">Every project benefits from design intelligence, manufacturing scale, and corrosion protection expertise working as one team.</p>
  </div>
  <div class="div-cards">

    <!-- ═══ 01 ENGINEERING ═══ -->
    <div class="div-card">
      <div class="div-visual eng">
        <div class="bp-noise"></div>
        <div class="bp-frame"></div>
        <div class="bp-scanline"></div>
        <div class="div-visual-num">01</div>
        <div class="bp-status"><div class="bp-status-dot"></div>Active</div>
        <div class="bp-corner tl"><svg width="14" height="14"><path d="M0 14V0h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner tr"><svg width="14" height="14"><path d="M14 14V0H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner bl"><svg width="14" height="14"><path d="M0 0v14h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner br"><svg width="14" height="14"><path d="M14 0v14H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-crosshair"><svg viewBox="0 0 24 24" fill="none"><line x1="12" y1="0" x2="12" y2="24" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><line x1="0" y1="12" x2="24" y2="12" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><circle cx="12" cy="12" r="4" stroke="rgba(59,123,219,0.15)" stroke-width="0.5" fill="none"/></svg></div>
        <div class="bp-label"><div class="bp-dot"></div>Engineering · 3D Plant Modelling</div>
        <div class="three-wrap" id="scene-eng"></div>
      </div>
      <div class="div-content">
        <div class="div-content-num">Division 01</div>
        <h3 class="div-content-title">Engineering Design</h3>
        <p class="div-content-desc">From concept to production-ready 3D models. Process, equipment, and piping design under one engineering team — with fabrication constraints built into every decision.</p>
        <div class="div-stat-inline"><span class="num">SP3D</span><span class="label">+ ANSYS + CAESAR II</span></div>
        <div class="div-pills">
          <a class="div-pill" href="#"><span>Process & Plant</span></a>
          <a class="div-pill" href="#"><span>Equipment Design</span></a>
          <a class="div-pill" href="#"><span>Piping Design</span></a>
          <a class="div-pill" href="#"><span>Water Treatment</span></a>
        </div>
        <a class="div-explore" href="#">Explore Engineering <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></a>
      </div>
    </div>

    <!-- ═══ 02 MANUFACTURING ═══ -->
    <div class="div-card">
      <div class="div-visual mfg">
        <div class="bp-noise"></div>
        <div class="bp-frame"></div>
        <div class="bp-scanline"></div>
        <div class="div-visual-num">02</div>
        <div class="bp-status"><div class="bp-status-dot"></div>Active</div>
        <div class="bp-corner tl"><svg width="14" height="14"><path d="M0 14V0h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner tr"><svg width="14" height="14"><path d="M14 14V0H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner bl"><svg width="14" height="14"><path d="M0 0v14h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner br"><svg width="14" height="14"><path d="M14 0v14H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-crosshair"><svg viewBox="0 0 24 24" fill="none"><line x1="12" y1="0" x2="12" y2="24" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><line x1="0" y1="12" x2="24" y2="12" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><circle cx="12" cy="12" r="4" stroke="rgba(59,123,219,0.15)" stroke-width="0.5" fill="none"/></svg></div>
        <div class="bp-label"><div class="bp-dot"></div>Fabrication · Pressure Vessel Manufacturing</div>
        <div class="three-wrap" id="scene-mfg"></div>
      </div>
      <div class="div-content">
        <div class="div-content-num">Division 02</div>
        <h3 class="div-content-title">Equipment Manufacturing</h3>
        <p class="div-content-desc">Steel, plastic, and FRP equipment fabricated to ASME, API, and PED standards. One of the largest integrated shop floors in the sector.</p>
        <div class="div-stat-inline"><span class="num">130,000+</span><span class="label">m² combined shop floor</span></div>
        <div class="div-pills">
          <a class="div-pill" href="#"><span>Steel Equipment</span></a>
          <a class="div-pill" href="#"><span>Plastic & FRP</span></a>
        </div>
        <a class="div-explore" href="#">Explore Manufacturing <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></a>
      </div>
    </div>

    <!-- ═══ 03 CORROSION PROTECTION ═══ -->
    <div class="div-card">
      <div class="div-visual cor">
        <div class="bp-noise"></div>
        <div class="bp-frame"></div>
        <div class="bp-scanline"></div>
        <div class="div-visual-num">03</div>
        <div class="bp-status"><div class="bp-status-dot"></div>Active</div>
        <div class="bp-corner tl"><svg width="14" height="14"><path d="M0 14V0h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner tr"><svg width="14" height="14"><path d="M14 14V0H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner bl"><svg width="14" height="14"><path d="M0 0v14h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner br"><svg width="14" height="14"><path d="M14 0v14H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-crosshair"><svg viewBox="0 0 24 24" fill="none"><line x1="12" y1="0" x2="12" y2="24" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><line x1="0" y1="12" x2="24" y2="12" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><circle cx="12" cy="12" r="4" stroke="rgba(59,123,219,0.15)" stroke-width="0.5" fill="none"/></svg></div>
        <div class="bp-label"><div class="bp-dot"></div>Protection · Rubber Lining Application</div>
        <div class="three-wrap" id="scene-cor"></div>
      </div>
      <div class="div-content">
        <div class="div-content-num">Division 03</div>
        <h3 class="div-content-title">Corrosion Protection</h3>
        <p class="div-content-desc">Rubber linings, plastic linings, coatings, and inspection services. HAW and GBT heritage — 40+ years protecting critical assets in the harshest chemical environments.</p>
        <div class="div-stat-inline"><span class="num">40+</span><span class="label">years of lining expertise</span></div>
        <div class="div-pills">
          <a class="div-pill" href="#"><span>Rubber Linings</span></a>
          <a class="div-pill" href="#"><span>Plastic Linings</span></a>
          <a class="div-pill" href="#"><span>Coatings & Resin</span></a>
          <a class="div-pill" href="#"><span>Inspection & Repair</span></a>
        </div>
        <a class="div-explore" href="#">Explore Protection <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></a>
      </div>
    </div>

    <!-- ═══ 04 RUBBER PRODUCTS ═══ -->
    <div class="div-card">
      <div class="div-visual rub">
        <div class="bp-noise"></div>
        <div class="bp-frame"></div>
        <div class="bp-scanline"></div>
        <div class="div-visual-num">04</div>
        <div class="bp-status"><div class="bp-status-dot"></div>Active</div>
        <div class="bp-corner tl"><svg width="14" height="14"><path d="M0 14V0h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner tr"><svg width="14" height="14"><path d="M14 14V0H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner bl"><svg width="14" height="14"><path d="M0 0v14h14" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-corner br"><svg width="14" height="14"><path d="M14 0v14H0" fill="none" stroke="rgba(59,123,219,0.18)" stroke-width="1"/></svg></div>
        <div class="bp-crosshair"><svg viewBox="0 0 24 24" fill="none"><line x1="12" y1="0" x2="12" y2="24" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><line x1="0" y1="12" x2="24" y2="12" stroke="rgba(59,123,219,0.3)" stroke-width="0.5"/><circle cx="12" cy="12" r="4" stroke="rgba(59,123,219,0.15)" stroke-width="0.5" fill="none"/></svg></div>
        <div class="bp-label"><div class="bp-dot"></div>R&D · Compound Development Lab</div>
        <div class="three-wrap" id="scene-rub"></div>
      </div>
      <div class="div-content">
        <div class="div-content-num">Division 04</div>
        <h3 class="div-content-title">Rubber Products</h3>
        <p class="div-content-desc">Custom compounds and engineered rubber products. Four decades of formulation expertise — from natural rubber to advanced fluoroelastomers.</p>
        <div class="div-stat-inline"><span class="num">2,000+</span><span class="label">proven formulations</span></div>
        <div class="div-pills">
          <a class="div-pill" href="#"><span>Custom Compounds</span></a>
          <a class="div-pill" href="#"><span>Engineered Products</span></a>
        </div>
        <a class="div-explore" href="#">Explore Rubber <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></a>
      </div>
    </div>

  </div>
</div>
</section>

<script>
/* ═══════════════════════════════════════════════════════════════════
   BLUEPRINT RENDERING ENGINE — Ultra-polished
   Dense engineering detail · Green glow bloom · Dimension annotations
   ═══════════════════════════════════════════════════════════════════ */

const BP = {
  base: 0x2a4a6e,
  baseBright: 0x3a6a9e,
  baseDim: 0x18304a,
  baseGhost: 0x142840,
  accent: 0x04E586,
  accentDim: 0x037a48,
  accentGlow: 0x04E586,
  grid: 0x1a3458,
};

/* ── Wireframe helpers ── */
function bpEdges(geo, color, opacity) {
  const edges = new THREE.EdgesGeometry(geo, 14);
  return new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
    color: color || BP.base, transparent: true,
    opacity: opacity !== undefined ? opacity : 0.5, depthWrite: false
  }));
}

function bpWire(geo, color, opacity) {
  return new THREE.LineSegments(new THREE.WireframeGeometry(geo), new THREE.LineBasicMaterial({
    color: color || BP.base, transparent: true,
    opacity: opacity !== undefined ? opacity : 0.2, depthWrite: false
  }));
}

function bpLine(a, b, color, opacity) {
  return new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([a, b]),
    new THREE.LineBasicMaterial({ color: color || BP.base, transparent: true, opacity: opacity || 0.35 })
  );
}

function bpRing(radius, segments, color, opacity) {
  const pts = [];
  for (let i = 0; i <= segments; i++) {
    const a = (i / segments) * Math.PI * 2;
    pts.push(new THREE.Vector3(Math.cos(a) * radius, 0, Math.sin(a) * radius));
  }
  return new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts),
    new THREE.LineBasicMaterial({ color: color || BP.base, transparent: true, opacity: opacity || 0.35 })
  );
}

/* Glow bloom: doubled, thicker, additive lines around highlighted geometry */
function bpGlowEdges(geo, color) {
  const edges = new THREE.EdgesGeometry(geo, 14);
  return new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
    color: color || BP.accent, transparent: true, opacity: 0.0,
    blending: THREE.AdditiveBlending, depthWrite: false, linewidth: 1
  }));
}

/* Dimension annotation line with ticks */
function bpDimension(start, end, offset, color, opacity) {
  const grp = new THREE.Group();
  const dir = new THREE.Vector3().subVectors(end, start).normalize();
  const perp = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0, 0, 1)).normalize().multiplyScalar(offset);
  const a = new THREE.Vector3().addVectors(start, perp);
  const b = new THREE.Vector3().addVectors(end, perp);
  const c = color || BP.baseDim;
  const o = opacity || 0.2;
  // Main dimension line
  grp.add(bpLine(a, b, c, o));
  // Tick at start
  grp.add(bpLine(start, a, c, o * 0.7));
  // Tick at end
  grp.add(bpLine(end, b, c, o * 0.7));
  return grp;
}

function setGroupColor(group, color, opacity) {
  group.traverse(c => {
    if (c.material && c.material.isLineBasicMaterial) {
      c.material.color.set(color);
      if (opacity !== undefined) c.material.opacity = opacity;
    }
  });
}

function setGlowOpacity(glows, opacity) {
  glows.forEach(g => {
    if (g.material) g.material.opacity = opacity;
  });
}

/* ═══════════════════════════════════════════════════════════════════
   SCENE MANAGER — Enhanced with hover brightness
   ═══════════════════════════════════════════════════════════════════ */
class BlueprintScene {
  constructor(el, setup) {
    this.el = el;
    this.mouse = {x:0, y:0};
    this.tRot = {x:0, y:0};
    this.visible = false;
    this.hovered = false;
    this.hoverIntensity = 0;
    this.time = 0;
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(22, 1, 0.1, 100);
    this.camera.position.set(0, 0, 14);
    this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.setClearColor(0x000000, 0);
    el.appendChild(this.renderer.domElement);

    this.scene.add(new THREE.AmbientLight(0xffffff, 0.08));

    this.group = new THREE.Group();
    this.scene.add(this.group);
    this.update = setup(this.group, this.scene, this) || null;

    this.resize();
    this._bind();
    this._loop = this._loop.bind(this);
    this._loop();
  }
  resize() {
    const w = this.el.clientWidth, h = this.el.clientHeight;
    if (!w || !h) return;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
  }
  _bind() {
    const card = this.el.closest('.div-card');
    card.addEventListener('mouseenter', () => this.hovered = true);
    card.addEventListener('mouseleave', () => { this.hovered = false; this.mouse.x = 0; this.mouse.y = 0; });
    card.addEventListener('mousemove', e => {
      const r = this.el.getBoundingClientRect();
      this.mouse.x = ((e.clientX - r.left) / r.width - 0.5) * 2;
      this.mouse.y = ((e.clientY - r.top) / r.height - 0.5) * 2;
    });
    const obs = new IntersectionObserver(e => e.forEach(x => this.visible = x.isIntersecting), {threshold: 0.05});
    obs.observe(this.el);
    window.addEventListener('resize', () => this.resize());
  }
  _loop() {
    requestAnimationFrame(this._loop);
    if (!this.visible) return;
    this.time += 0.016;
    // Smooth hover intensity
    const targetHover = this.hovered ? 1 : 0;
    this.hoverIntensity += (targetHover - this.hoverIntensity) * 0.04;
    // Parallax
    this.tRot.y = this.mouse.x * 0.18;
    this.tRot.x = this.mouse.y * 0.1;
    this.group.rotation.y += (this.tRot.y - this.group.rotation.y) * 0.04;
    this.group.rotation.x += (this.tRot.x - this.group.rotation.x) * 0.04;
    if (this.update) this.update(this.time, this.hoverIntensity);
    this.renderer.render(this.scene, this.camera);
  }
}


/* ═══════════════════════════════════════════════════════════════════
   SCENE 1: ENGINEERING — Dense plant assembly
   ═══════════════════════════════════════════════════════════════════ */
new BlueprintScene(document.getElementById('scene-eng'), (group, scene, ctx) => {
  const sections = [];
  const glows = [];

  // ── Section 0: Vertical pressure vessel (highly detailed) ──
  const vesselGrp = new THREE.Group();
  const vesselGlow = [];

  // Shell
  const vGeo = new THREE.CylinderGeometry(0.5, 0.5, 2.2, 28, 1, true);
  vesselGrp.add(bpEdges(vGeo, BP.base, 0.5));
  const vg = bpGlowEdges(vGeo); vesselGrp.add(vg); vesselGlow.push(vg);

  // Heads
  const headGeo = new THREE.SphereGeometry(0.5, 20, 12, 0, Math.PI*2, 0, Math.PI/2);
  const topH = bpEdges(headGeo, BP.base, 0.5); topH.position.y = 1.1; vesselGrp.add(topH);
  const topHg = bpGlowEdges(headGeo); topHg.position.y = 1.1; vesselGrp.add(topHg); vesselGlow.push(topHg);
  const botH = bpEdges(headGeo, BP.base, 0.5); botH.position.y = -1.1; botH.rotation.x = Math.PI; vesselGrp.add(botH);
  const botHg = bpGlowEdges(headGeo); botHg.position.y = -1.1; botHg.rotation.x = Math.PI; vesselGrp.add(botHg); vesselGlow.push(botHg);

  // Weld seam rings
  [-0.7, -0.35, 0, 0.35, 0.7].forEach(y => {
    const r = bpRing(0.505, 36, BP.baseDim, 0.18); r.rotation.x = Math.PI/2; r.position.y = y; vesselGrp.add(r);
  });

  // Top nozzle assembly
  const nGeo1 = new THREE.CylinderGeometry(0.1, 0.1, 0.55, 14);
  vesselGrp.add(bpEdges(nGeo1, BP.base, 0.5).translateY(1.65));
  const fGeo1 = new THREE.CylinderGeometry(0.19, 0.19, 0.05, 14);
  vesselGrp.add(bpEdges(fGeo1, BP.base, 0.5).translateY(1.92));
  // Bolt circle on top flange
  for (let i = 0; i < 8; i++) {
    const a = (i/8)*Math.PI*2;
    const bGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 6);
    const bolt = bpEdges(bGeo, BP.baseDim, 0.3);
    bolt.position.set(Math.cos(a)*0.155, 1.92, Math.sin(a)*0.155);
    vesselGrp.add(bolt);
  }
  // Reinforcing pad
  const padGeo = new THREE.TorusGeometry(0.13, 0.02, 8, 20);
  const pad = bpEdges(padGeo, BP.baseDim, 0.2); pad.position.y = 1.38; vesselGrp.add(pad);

  // Side nozzle with detail
  const snGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 12);
  const sn = bpEdges(snGeo, BP.base, 0.5); sn.rotation.z = Math.PI/2; sn.position.set(0.74, 0.2, 0); vesselGrp.add(sn);
  const sfGeo = new THREE.CylinderGeometry(0.14, 0.14, 0.04, 12);
  const sf = bpEdges(sfGeo, BP.base, 0.5); sf.rotation.z = Math.PI/2; sf.position.set(0.99, 0.2, 0); vesselGrp.add(sf);
  // Side pad
  const sp = bpEdges(new THREE.TorusGeometry(0.1, 0.015, 8, 16), BP.baseDim, 0.18);
  sp.rotation.z = Math.PI/2; sp.position.set(0.5, 0.2, 0); vesselGrp.add(sp);

  // Bottom outlet
  const boGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.35, 10);
  vesselGrp.add(bpEdges(boGeo, BP.baseDim, 0.35).translateY(-1.52));

  // Manway (access hatch)
  const mwGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.12, 16);
  const mw = bpEdges(mwGeo, BP.baseDim, 0.3); mw.rotation.x = Math.PI/2; mw.position.set(0, 0.5, 0.51); vesselGrp.add(mw);

  // Internal tray levels (ghosted)
  [-0.5, 0, 0.5].forEach(y => {
    const tray = bpEdges(new THREE.CircleGeometry(0.46, 20), BP.baseGhost, 0.08);
    tray.rotation.x = -Math.PI/2; tray.position.y = y; vesselGrp.add(tray);
  });

  group.add(vesselGrp);
  sections.push(vesselGrp);
  glows.push(vesselGlow);

  // ── Section 1: Heat exchanger ──
  const hxGrp = new THREE.Group();
  const hxGlow = [];
  const hxGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 22, 1, true);
  const hxShell = bpEdges(hxGeo, BP.base, 0.45); hxShell.rotation.z = Math.PI/2; hxGrp.add(hxShell);
  const hxg = bpGlowEdges(hxGeo); hxg.rotation.z = Math.PI/2; hxGrp.add(hxg); hxGlow.push(hxg);

  // Tube sheets
  [-0.75, 0.75].forEach(x => {
    const ts = bpEdges(new THREE.CylinderGeometry(0.3, 0.3, 0.04, 22), BP.base, 0.45);
    ts.rotation.z = Math.PI/2; ts.position.x = x; hxGrp.add(ts);
  });
  // Channel head
  const chGeo = new THREE.SphereGeometry(0.3, 16, 10, 0, Math.PI*2, 0, Math.PI/2);
  const ch = bpEdges(chGeo, BP.base, 0.35); ch.rotation.z = Math.PI/2; ch.position.x = -0.78; hxGrp.add(ch);

  // Internal tubes
  for (let i = 0; i < 7; i++) {
    const a = (i/7)*Math.PI*2;
    const r = 0.14;
    hxGrp.add(bpLine(
      new THREE.Vector3(-0.72, Math.sin(a)*r, Math.cos(a)*r),
      new THREE.Vector3(0.72, Math.sin(a)*r, Math.cos(a)*r),
      BP.baseGhost, 0.1
    ));
  }
  // Baffles
  [-0.3, 0, 0.3].forEach(x => {
    const b = bpEdges(new THREE.CircleGeometry(0.27, 16), BP.baseGhost, 0.06);
    b.rotation.y = Math.PI/2; b.position.x = x; hxGrp.add(b);
  });
  // Support legs
  [-0.4, 0.4].forEach(x => {
    hxGrp.add(bpLine(new THREE.Vector3(x, -0.3, 0), new THREE.Vector3(x, -0.7, 0), BP.baseDim, 0.2));
    hxGrp.add(bpEdges(new THREE.BoxGeometry(0.25, 0.03, 0.15), BP.baseDim, 0.2).translateX(x).translateY(-0.72));
  });

  hxGrp.position.set(1.9, -0.4, -0.5);
  group.add(hxGrp);
  sections.push(hxGrp);
  glows.push(hxGlow);

  // ── Section 2: Piping + pump ──
  const pipeGrp = new THREE.Group();
  const pipeGlow = [];
  const pSegs = [
    [new THREE.Vector3(0.99, 0.2, 0), new THREE.Vector3(1.5, 0.2, 0)],
    [new THREE.Vector3(1.5, 0.2, 0), new THREE.Vector3(1.5, 0.2, -0.5)],
    [new THREE.Vector3(1.5, 0.2, -0.5), new THREE.Vector3(1.5, -0.4, -0.5)],
    [new THREE.Vector3(1.5, -0.4, -0.5), new THREE.Vector3(1.15, -0.4, -0.5)],
    // Vertical green run
    [new THREE.Vector3(0, 1.92, 0), new THREE.Vector3(0, 2.25, 0)],
    [new THREE.Vector3(0, 2.25, 0), new THREE.Vector3(-1.1, 2.25, 0)],
    [new THREE.Vector3(-1.1, 2.25, 0), new THREE.Vector3(-1.1, 0.0, 0)],
  ];
  pSegs.forEach(([a, b]) => pipeGrp.add(bpLine(a, b, BP.base, 0.4)));
  // Elbows (small circles at turns)
  [[1.5, 0.2, 0], [-1.1, 2.25, 0], [0, 2.25, 0]].forEach(([x,y,z]) => {
    const elbow = bpEdges(new THREE.SphereGeometry(0.035, 8, 6), BP.base, 0.3);
    elbow.position.set(x, y, z); pipeGrp.add(elbow);
  });
  // Valve on vertical pipe
  const valve = bpEdges(new THREE.CylinderGeometry(0.06, 0.06, 0.15, 10), BP.base, 0.4);
  valve.position.set(-1.1, 1.2, 0); pipeGrp.add(valve);
  const vHandle = bpEdges(new THREE.BoxGeometry(0.18, 0.02, 0.02), BP.base, 0.35);
  vHandle.position.set(-1.1, 1.28, 0); pipeGrp.add(vHandle);

  // Pump
  const pumpGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.22, 14);
  pipeGrp.add(bpEdges(pumpGeo, BP.base, 0.45).translateX(-1.1).translateY(-0.15));
  const pg = bpGlowEdges(pumpGeo); pg.position.set(-1.1, -0.15, 0); pipeGrp.add(pg); pipeGlow.push(pg);
  pipeGrp.add(bpEdges(new THREE.BoxGeometry(0.45, 0.06, 0.35), BP.base, 0.4).translateX(-1.1).translateY(-0.3));
  // Motor cylinder
  pipeGrp.add(bpEdges(new THREE.CylinderGeometry(0.1, 0.1, 0.25, 10), BP.baseDim, 0.25).translateX(-1.1).translateY(-0.15).rotateX(Math.PI/2).translateY(-0.25));

  group.add(pipeGrp);
  sections.push(pipeGrp);
  glows.push(pipeGlow);

  // ── Section 3: Structural frame ──
  const rackGrp = new THREE.Group();
  [-1.5, 1.5].forEach(x => {
    [-0.4, 0.4].forEach(z => {
      rackGrp.add(bpLine(new THREE.Vector3(x,-1.5,z), new THREE.Vector3(x,2.5,z), BP.baseDim, 0.18));
    });
  });
  [-0.3, 0.8, 1.6, 2.5].forEach(y => {
    rackGrp.add(bpLine(new THREE.Vector3(-1.5,y,-0.4), new THREE.Vector3(1.5,y,-0.4), BP.baseGhost, 0.12));
    rackGrp.add(bpLine(new THREE.Vector3(-1.5,y,0.4), new THREE.Vector3(1.5,y,0.4), BP.baseGhost, 0.12));
  });
  // Diagonal bracing
  rackGrp.add(bpLine(new THREE.Vector3(-1.5,-0.3,-0.4), new THREE.Vector3(-1.5,0.8,0.4), BP.baseGhost, 0.08));
  rackGrp.add(bpLine(new THREE.Vector3(1.5,-0.3,0.4), new THREE.Vector3(1.5,0.8,-0.4), BP.baseGhost, 0.08));

  group.add(rackGrp);
  sections.push(rackGrp);
  glows.push([]);

  // ── Dimension annotations ──
  group.add(bpDimension(new THREE.Vector3(-0.5, -1.6, 0.5), new THREE.Vector3(0.5, -1.6, 0.5), 0.25, BP.baseDim, 0.12));
  group.add(bpDimension(new THREE.Vector3(-0.55, -1.1, 0.5), new THREE.Vector3(-0.55, 1.1, 0.5), 0.3, BP.baseDim, 0.1));

  // ── Floor grid ──
  for (let i = -5; i <= 5; i++) {
    group.add(bpLine(new THREE.Vector3(i*0.45,-1.5,-2.2), new THREE.Vector3(i*0.45,-1.5,2.2), BP.grid, 0.04));
    group.add(bpLine(new THREE.Vector3(-2.2,-1.5,i*0.45), new THREE.Vector3(2.2,-1.5,i*0.45), BP.grid, 0.04));
  }

  group.rotation.set(0.35, 0.5, 0);
  group.position.y = -0.2;

  let activeSection = 0;
  let timer = 0;
  const CYCLE = 2.8;

  return (t, hover) => {
    timer += 0.016;
    if (timer > CYCLE) { timer = 0; activeSection = (activeSection + 1) % sections.length; }
    const progress = timer / CYCLE;

    sections.forEach((sec, i) => {
      if (i === activeSection) {
        // Smooth fade envelope with a brief flash
        let fade;
        if (progress < 0.06) fade = Math.pow(progress / 0.06, 0.5); // Quick rise
        else if (progress < 0.12) fade = 1.0 - (progress - 0.06) / 0.06 * 0.2; // Slight settle from flash
        else if (progress > 0.88) fade = (1 - progress) / 0.12;
        else fade = 0.8;
        const baseOp = 0.12 + hover * 0.08;
        setGroupColor(sec, BP.accent, fade * 0.65 + baseOp);
        if (glows[i]) setGlowOpacity(glows[i], fade * 0.25);
      } else {
        const dimOp = 0.2 + hover * 0.12; // Brighter on hover
        setGroupColor(sec, BP.base, dimOp);
        if (glows[i]) setGlowOpacity(glows[i], 0);
      }
    });

    group.rotation.y += 0.0003;
  };
});


/* ═══════════════════════════════════════════════════════════════════
   SCENE 2: MANUFACTURING — Horizontal pressure vessel
   ═══════════════════════════════════════════════════════════════════ */
new BlueprintScene(document.getElementById('scene-mfg'), (group, scene, ctx) => {
  const sections = [];
  const glows = [];

  // ── Section 0: Main shell ──
  const shellGrp = new THREE.Group();
  const shellGlow = [];
  const sGeo = new THREE.CylinderGeometry(0.8, 0.8, 2.8, 36, 1, true);
  const s = bpEdges(sGeo, BP.base, 0.45); s.rotation.z = Math.PI/2; shellGrp.add(s);
  const sg = bpGlowEdges(sGeo); sg.rotation.z = Math.PI/2; shellGrp.add(sg); shellGlow.push(sg);
  // Longitudinal lines
  for (let i = 0; i < 12; i++) {
    const a = (i/12)*Math.PI*2; const r = 0.8;
    shellGrp.add(bpLine(
      new THREE.Vector3(-1.4, Math.sin(a)*r, Math.cos(a)*r),
      new THREE.Vector3(1.4, Math.sin(a)*r, Math.cos(a)*r),
      BP.baseGhost, 0.07
    ));
  }
  group.add(shellGrp); sections.push(shellGrp); glows.push(shellGlow);

  // ── Section 1: Heads ──
  const headGrp = new THREE.Group();
  const headGlow = [];
  const hGeo = new THREE.SphereGeometry(0.8, 28, 16, 0, Math.PI*2, 0, Math.PI/2.5);
  const lH = bpEdges(hGeo, BP.base, 0.45); lH.rotation.z = -Math.PI/2; lH.position.x = -1.4; headGrp.add(lH);
  const lHg = bpGlowEdges(hGeo); lHg.rotation.z = -Math.PI/2; lHg.position.x = -1.4; headGrp.add(lHg); headGlow.push(lHg);
  const rH = bpEdges(hGeo, BP.base, 0.45); rH.rotation.z = Math.PI/2; rH.position.x = 1.4; headGrp.add(rH);
  const rHg = bpGlowEdges(hGeo); rHg.rotation.z = Math.PI/2; rHg.position.x = 1.4; headGrp.add(rHg); headGlow.push(rHg);
  group.add(headGrp); sections.push(headGrp); glows.push(headGlow);

  // ── Section 2: Welds + internals ──
  const weldGrp = new THREE.Group();
  [-0.8, -0.4, 0, 0.4, 0.8].forEach(x => {
    const wr = bpRing(0.81, 44, BP.base, 0.4); wr.rotation.z = Math.PI/2; wr.position.x = x; weldGrp.add(wr);
    const wr2 = bpRing(0.84, 44, BP.baseDim, 0.12); wr2.rotation.z = Math.PI/2; wr2.position.x = x; weldGrp.add(wr2);
  });
  // Baffles
  for (let i = -3; i <= 3; i++) {
    const b = bpEdges(new THREE.CircleGeometry(0.72, 28), BP.baseGhost, 0.06);
    b.rotation.y = Math.PI/2; b.position.x = i * 0.36; weldGrp.add(b);
  }
  group.add(weldGrp); sections.push(weldGrp); glows.push([]);

  // ── Section 3: Nozzles ──
  const nozGrp = new THREE.Group();
  const nozGlow = [];
  [[-0.3, 0.14], [0.5, 0.09], [-0.9, 0.08]].forEach(([x, r]) => {
    const nGeo = new THREE.CylinderGeometry(r, r, 0.5, 14);
    nozGrp.add(bpEdges(nGeo, BP.base, 0.45).translateX(x).translateY(1.05));
    const ng = bpGlowEdges(nGeo); ng.position.set(x, 1.05, 0); nozGrp.add(ng); nozGlow.push(ng);
    const fGeo = new THREE.CylinderGeometry(r+0.05, r+0.05, 0.04, 14);
    nozGrp.add(bpEdges(fGeo, BP.base, 0.45).translateX(x).translateY(1.3));
    // Bolt circle
    for (let i = 0; i < 6; i++) {
      const a = (i/6)*Math.PI*2;
      nozGrp.add(bpEdges(new THREE.CylinderGeometry(0.01, 0.01, 0.05, 6), BP.baseDim, 0.25)
        .translateX(x + Math.cos(a)*(r+0.025)).translateY(1.3).translateZ(Math.sin(a)*(r+0.025)));
    }
    // Reinforcing pad
    const rpGeo = new THREE.TorusGeometry(r + 0.01, 0.015, 6, 16);
    nozGrp.add(bpEdges(rpGeo, BP.baseDim, 0.15).translateX(x).translateY(0.82));
  });
  group.add(nozGrp); sections.push(nozGrp); glows.push(nozGlow);

  // ── Section 4: Saddles ──
  const saddleGrp = new THREE.Group();
  [-0.9, 0.9].forEach(x => {
    const base = bpEdges(new THREE.BoxGeometry(0.9, 0.04, 0.5), BP.base, 0.35);
    base.position.set(x, -0.84, 0); saddleGrp.add(base);
    const arcPts = [];
    for (let i = 0; i <= 24; i++) {
      const a = -Math.PI/2 + (i/24)*Math.PI;
      arcPts.push(new THREE.Vector3(x, Math.sin(a)*0.8, Math.cos(a)*0.42));
    }
    saddleGrp.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(arcPts),
      new THREE.LineBasicMaterial({color: BP.base, transparent: true, opacity: 0.3})));
    // Web plate
    saddleGrp.add(bpLine(new THREE.Vector3(x-0.38,-0.84,0), new THREE.Vector3(x-0.38,0,0), BP.baseDim, 0.15));
    saddleGrp.add(bpLine(new THREE.Vector3(x+0.38,-0.84,0), new THREE.Vector3(x+0.38,0,0), BP.baseDim, 0.15));
    // Gussets
    saddleGrp.add(bpLine(new THREE.Vector3(x-0.38,-0.84,0), new THREE.Vector3(x, -0.4, 0), BP.baseGhost, 0.1));
    saddleGrp.add(bpLine(new THREE.Vector3(x+0.38,-0.84,0), new THREE.Vector3(x, -0.4, 0), BP.baseGhost, 0.1));
  });
  group.add(saddleGrp); sections.push(saddleGrp); glows.push([]);

  // Dimensions
  group.add(bpDimension(new THREE.Vector3(-1.4, -0.9, 0.5), new THREE.Vector3(1.4, -0.9, 0.5), 0.25, BP.baseDim, 0.1));

  // Floor grid
  for (let i = -4; i <= 4; i++) {
    group.add(bpLine(new THREE.Vector3(i*0.45,-0.88,-1.5), new THREE.Vector3(i*0.45,-0.88,1.5), BP.grid, 0.035));
  }

  group.rotation.set(0.22, 0.4, 0);
  group.position.y = -0.1;

  let activeSection = 0, timer = 0;
  const CYCLE = 2.4;

  return (t, hover) => {
    timer += 0.016;
    if (timer > CYCLE) { timer = 0; activeSection = (activeSection + 1) % sections.length; }
    const progress = timer / CYCLE;
    sections.forEach((sec, i) => {
      if (i === activeSection) {
        let fade;
        if (progress < 0.06) fade = Math.pow(progress / 0.06, 0.5);
        else if (progress < 0.12) fade = 1.0 - (progress - 0.06) / 0.06 * 0.2;
        else if (progress > 0.88) fade = (1 - progress) / 0.12;
        else fade = 0.8;
        setGroupColor(sec, BP.accent, fade * 0.6 + 0.12 + hover * 0.08);
        if (glows[i]) setGlowOpacity(glows[i], fade * 0.2);
      } else {
        setGroupColor(sec, BP.base, 0.18 + hover * 0.1);
        if (glows[i]) setGlowOpacity(glows[i], 0);
      }
    });
    group.rotation.y += 0.0003;
  };
});


/* ═══════════════════════════════════════════════════════════════════
   SCENE 3: CORROSION — Cutaway lining layers
   ═══════════════════════════════════════════════════════════════════ */
new BlueprintScene(document.getElementById('scene-cor'), (group, scene, ctx) => {
  const sections = [];
  const glows = [];
  const arc = Math.PI * 1.4;
  const startAngle = -Math.PI * 0.15;
  const h = 2.2;

  const layers = [
    { r: 0.95, label: 'Steel' },
    { r: 0.86, label: 'Primer' },
    { r: 0.78, label: 'Adhesive' },
    { r: 0.68, label: 'Lining' },
  ];
  const layerGrps = [];
  const layerTargetY = [0.5, 0.17, -0.17, -0.5];

  layers.forEach((l, i) => {
    const grp = new THREE.Group();
    const gw = [];
    const cGeo = new THREE.CylinderGeometry(l.r, l.r, h - i*0.08, 36, 1, true, startAngle, arc);
    grp.add(bpEdges(cGeo, BP.base, 0.4));
    const cg = bpGlowEdges(cGeo); grp.add(cg); gw.push(cg);
    if (i >= 2) grp.add(bpWire(cGeo, BP.baseGhost, 0.05));

    // Top/bottom arcs
    [1, -1].forEach(dir => {
      const pts = [];
      for (let j = 0; j <= 44; j++) {
        const a = startAngle + (j/44) * arc;
        pts.push(new THREE.Vector3(Math.cos(a)*l.r, dir*(h - i*0.08)/2, Math.sin(a)*l.r));
      }
      grp.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineBasicMaterial({ color: BP.base, transparent: true, opacity: 0.25 })));
    });
    // Thickness annotation
    const annoY = (i - 1.5) * 0.45;
    grp.add(bpLine(new THREE.Vector3(l.r + 0.1, annoY, 0), new THREE.Vector3(l.r + 0.6, annoY, 0), BP.baseDim, 0.15));
    // Tick
    grp.add(bpLine(new THREE.Vector3(l.r + 0.6, annoY - 0.04, 0), new THREE.Vector3(l.r + 0.6, annoY + 0.04, 0), BP.baseDim, 0.15));
    // Dot at annotation end
    const dot = bpEdges(new THREE.SphereGeometry(0.02, 6, 6), BP.baseDim, 0.2);
    dot.position.set(l.r + 0.6, annoY, 0); grp.add(dot);

    group.add(grp); sections.push(grp); layerGrps.push(grp); glows.push(gw);
  });

  // Floor grid
  for (let i = -3; i <= 3; i++) {
    group.add(bpLine(new THREE.Vector3(i*0.5,-1.5,-1.5), new THREE.Vector3(i*0.5,-1.5,1.5), BP.grid, 0.04));
    group.add(bpLine(new THREE.Vector3(-1.5,-1.5,i*0.5), new THREE.Vector3(1.5,-1.5,i*0.5), BP.grid, 0.04));
  }

  group.rotation.set(0.18, -0.3, 0);
  group.position.y = -0.05;

  let activeSection = 0, timer = 0, exploded = 0;
  const CYCLE = 2.8;

  return (t, hover) => {
    timer += 0.016;
    if (timer > CYCLE) { timer = 0; activeSection = (activeSection + 1) % sections.length; }
    const progress = timer / CYCLE;

    const targetExplode = ctx.hovered ? 1 : 0;
    exploded += (targetExplode - exploded) * 0.025;
    layerGrps.forEach((grp, i) => { grp.position.y = layerTargetY[i] * exploded * 0.6; });

    sections.forEach((sec, i) => {
      if (i === activeSection) {
        let fade;
        if (progress < 0.06) fade = Math.pow(progress / 0.06, 0.5);
        else if (progress < 0.12) fade = 1.0 - (progress - 0.06) / 0.06 * 0.2;
        else if (progress > 0.88) fade = (1 - progress) / 0.12;
        else fade = 0.8;
        setGroupColor(sec, BP.accent, fade * 0.6 + 0.1 + hover * 0.08);
        if (glows[i]) setGlowOpacity(glows[i], fade * 0.18);
      } else {
        setGroupColor(sec, BP.base, 0.18 + hover * 0.1);
        if (glows[i]) setGlowOpacity(glows[i], 0);
      }
    });
    group.rotation.y += 0.0004;
  };
});


/* ═══════════════════════════════════════════════════════════════════
   SCENE 4: RUBBER — Molecular compound
   ═══════════════════════════════════════════════════════════════════ */
new BlueprintScene(document.getElementById('scene-rub'), (group, scene, ctx) => {
  const sections = [];
  const glows = [];

  const nodeData = [
    {p:[-1.5, 0.0, 0.0], r:0.26},
    {p:[-0.7, 0.55, 0.25], r:0.20},
    {p:[0.0, -0.08, -0.15], r:0.30},
    {p:[0.75, 0.45, 0.35], r:0.22},
    {p:[1.4, -0.18, -0.08], r:0.24},
    {p:[2.0, 0.25, 0.15], r:0.18},
    {p:[-0.25, 1.2, 0.08], r:0.18},
    {p:[0.25, 1.75, -0.15], r:0.16},
    {p:[-0.45, -1.1, 0.25], r:0.18},
    {p:[0.55, -1.0, -0.08], r:0.20},
    {p:[1.2, -1.35, 0.15], r:0.16},
  ];
  const bonds = [[0,1],[1,2],[2,3],[3,4],[4,5],[2,6],[6,7],[1,8],[3,9],[8,9],[9,10]];

  const mainGrp = new THREE.Group(), mainGlow = [];
  const branchGrp = new THREE.Group(), branchGlow = [];
  const crossGrp = new THREE.Group(), crossGlow = [];
  const bondGrp = new THREE.Group();

  const nodeMeshes = [];
  nodeData.forEach((n, i) => {
    const geo = new THREE.IcosahedronGeometry(n.r, 1);
    const edges = bpEdges(geo, BP.base, 0.4);
    edges.position.set(...n.p);
    edges.userData = { basePos: [...n.p], phase: i * 0.9, r: n.r };

    const glow = bpGlowEdges(geo);
    glow.position.set(...n.p);
    glow.userData = { parent: edges };

    let tG, tGl;
    if (i <= 5) { tG = mainGrp; tGl = mainGlow; }
    else if (i <= 7) { tG = branchGrp; tGl = branchGlow; }
    else { tG = crossGrp; tGl = crossGlow; }

    tG.add(edges); tG.add(glow); tGl.push(glow);
    nodeMeshes.push(edges);
  });

  bonds.forEach(([a, b]) => {
    const line = bpLine(new THREE.Vector3(...nodeData[a].p), new THREE.Vector3(...nodeData[b].p), BP.base, 0.25);
    line.userData = { a, b };
    bondGrp.add(line);
  });

  group.add(mainGrp); group.add(branchGrp); group.add(crossGrp); group.add(bondGrp);
  sections.push(mainGrp); sections.push(branchGrp); sections.push(crossGrp); sections.push(bondGrp);
  glows.push(mainGlow); glows.push(branchGlow); glows.push(crossGlow); glows.push([]);

  // Orbital dots
  const orbitals = [];
  for (let i = 0; i < 12; i++) {
    const dot = new THREE.Points(
      new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]),
      new THREE.PointsMaterial({color: BP.accent, size: 0.035, transparent: true, opacity: 0.45, sizeAttenuation: true})
    );
    dot.userData = {
      orbit: 0.3 + Math.random() * 0.25,
      speed: 0.4 + Math.random() * 0.5,
      phase: Math.random() * Math.PI * 2,
      tilt: (Math.random()-0.5) * Math.PI * 0.5,
      center: Math.floor(Math.random() * nodeData.length)
    };
    group.add(dot); orbitals.push(dot);
  }

  // Floor grid
  for (let i = -4; i <= 4; i++) {
    group.add(bpLine(new THREE.Vector3(i*0.5,-2,-2), new THREE.Vector3(i*0.5,-2,2), BP.grid, 0.03));
    group.add(bpLine(new THREE.Vector3(-2,-2,i*0.5), new THREE.Vector3(2,-2,i*0.5), BP.grid, 0.03));
  }

  group.rotation.set(0.12, 0.3, 0);
  group.position.y = -0.05;

  let activeSection = 0, timer = 0;
  const CYCLE = 2.5;

  return (t, hover) => {
    timer += 0.016;
    if (timer > CYCLE) { timer = 0; activeSection = (activeSection + 1) % sections.length; }
    const progress = timer / CYCLE;

    // Float nodes
    nodeMeshes.forEach((m, i) => {
      const d = m.userData;
      m.position.x = d.basePos[0] + Math.sin(t*0.4 + d.phase) * 0.06;
      m.position.y = d.basePos[1] + Math.cos(t*0.5 + d.phase) * 0.08;
      m.position.z = d.basePos[2] + Math.sin(t*0.35 + d.phase*0.7) * 0.04;
    });
    // Update glow positions
    [mainGrp, branchGrp, crossGrp].forEach(g => {
      g.children.forEach(c => { if (c.userData && c.userData.parent) c.position.copy(c.userData.parent.position); });
    });
    // Update bonds
    bondGrp.children.forEach(line => {
      if (!line.userData || line.userData.a === undefined) return;
      const pa = nodeMeshes[line.userData.a].position;
      const pb = nodeMeshes[line.userData.b].position;
      const pos = line.geometry.attributes.position;
      pos.array[0] = pa.x; pos.array[1] = pa.y; pos.array[2] = pa.z;
      pos.array[3] = pb.x; pos.array[4] = pb.y; pos.array[5] = pb.z;
      pos.needsUpdate = true;
    });
    // Orbitals
    orbitals.forEach(o => {
      const d = o.userData;
      const center = nodeMeshes[d.center].position;
      const angle = t * d.speed + d.phase;
      const pos = o.geometry.attributes.position;
      pos.array[0] = center.x + Math.cos(angle) * d.orbit * Math.cos(d.tilt);
      pos.array[1] = center.y + Math.sin(angle) * d.orbit;
      pos.array[2] = center.z + Math.cos(angle) * d.orbit * Math.sin(d.tilt);
      pos.needsUpdate = true;
    });

    sections.forEach((sec, i) => {
      if (i === activeSection) {
        let fade;
        if (progress < 0.06) fade = Math.pow(progress / 0.06, 0.5);
        else if (progress < 0.12) fade = 1.0 - (progress - 0.06) / 0.06 * 0.2;
        else if (progress > 0.88) fade = (1 - progress) / 0.12;
        else fade = 0.8;
        setGroupColor(sec, BP.accent, fade * 0.6 + 0.12 + hover * 0.08);
        if (glows[i]) setGlowOpacity(glows[i], fade * 0.18);
      } else {
        setGroupColor(sec, BP.base, 0.18 + hover * 0.1);
        if (glows[i]) setGlowOpacity(glows[i], 0);
      }
    });
    group.rotation.y += 0.0004;
  };
});


/* ═══════════════════════════════════════════════════════════════════
   ENTRANCE ANIMATIONS
   ═══════════════════════════════════════════════════════════════════ */
const cardObs = new IntersectionObserver(e => {
  e.forEach(x => { if (x.isIntersecting) x.target.classList.add('visible'); });
}, {threshold: 0.1, rootMargin: '0px 0px -60px 0px'});
document.querySelectorAll('.div-card').forEach(c => cardObs.observe(c));

// Header entrance
const hdrObs = new IntersectionObserver(e => {
  e.forEach(x => { if (x.isIntersecting) x.target.classList.add('visible'); });
}, {threshold: 0.3});
hdrObs.observe(document.getElementById('s2hdr'));
</script>
</body>
</html>
